@using InventoryHubClient.DTO;
@using InventoryHubClient.Service
@inject InventoryHubClient.Service.IService ServiceState
@inject InventoryHubClient.Service.Storage.ISessionStorage SessionStorage

@code
{
    [Parameter]
    public Product Product { get; set; } = new Product();
    
    [Parameter]
    public EventCallback<Product> OnProductUpdated { get; set; }
    
    private ProductList ProductList = new ProductList();

    // This will automatically fill the product list table and the product update form from database
    protected override async Task OnInitializedAsync()
    {   
        // Try to get the cached product list from session storage
        var cachedProductList = await SessionStorage.GetItemAsync<ProductList>("CachedProductList");
        // If cached product list is available, use it
        if (cachedProductList != null && cachedProductList.Products.Count > 0)
        {
            ProductList = cachedProductList;
        }
        else
        {
            // If cache is empty, fetch from API and store in session storage
            ProductList = await ServiceState.GetProductListAsync();
            await SessionStorage.SetItemAsync("CachedProductList", ProductList);
        }

        var storedProduct = await SessionStorage.GetItemAsync<Product>("SelectedProduct");
        
        if(storedProduct != null)
        {
            Product = storedProduct;
        }
    }

    private Task EditProduct(Product selectedProduct)
    {
        Product = new Product
        {
            Id = selectedProduct.Id,
            Name = selectedProduct.Name,
            Price = selectedProduct.Price,
            Stock = selectedProduct.Stock
        };

        return Task.CompletedTask;
    }

    private async Task HandleProductUpdate()

    { 
        // Copy product to session storage
        // This is to ensure that the product data is available in session storage for other components or pages
        await SessionStorage.SetItemAsync("SelectedProduct", Product);
        
        // This ensures your server-side data is updated.
        await ServiceState.UpdateProductAsync(Product);

        // Clean UI after update. Reset the form after submission
        Product = new Product(); 
        
        if (OnProductUpdated.HasDelegate)
        {
            await OnProductUpdated.InvokeAsync(Product);
        }

        // Clear the session storage after updating the product. Keeps session storage clean and up-to-date
        await SessionStorage.RemoveItemAsync("SelectedProduct");

        // Ensures your UI reflects the latest data
        ProductList = await ServiceState.GetProductListAsync();
        // Refresh the CachedProductList without API extra call
        await SessionStorage.SetItemAsync("CachedProductList", ProductList);
    }
}  

<div class="container">
    <div class="row">
        <div class="col-md-4"></div>
        <div class="col-md-4 text-center"><h3><strong>Product List</strong></h3></div>
        <div class="col-md-4"></div>
    </div>
    <div class="row">
        <div class="col-md-2"></div>
        <div class="col-md-8">
            @if(ProductList.Products.Count == 0)
            {
                <p>No Product Available.</p>
            }
            else
            {
                <table class="table table-striped table-bordered table-hover table-sm">
                    <thead class="table-dark">
                        <tr>
                            <th>Name</th>
                            <th>Price</th>
                            <th>Stock</th>
                            <th>Update</th>
                            <th>Remove</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach(var product in ProductList.Products)
                        {
                            <tr>
                                <td>@product.Name</td>
                                <td>@product.Price</td>
                                <td>@product.Stock</td>
                                <td><button class="btn btn-primary" type="button" data-bs-toggle="modal" data-bs-target="#UpdateProduct" @onclick="() => EditProduct(product)">Update</button></td>
                                <td><button class="btn btn-danger" @onclick="() => ServiceState.RemoveProductAsync(product)">Remove</button></td>
                            </tr>
                        }
                    </tbody>
                </table>
            }
        </div>
        <div class="col-md-2"></div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="UpdateProduct" tabindex="-1" aria-labelledby="UpdateProductLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      
      <!-- Modal Header -->
      <div class="modal-header">
        <h5 class="modal-title" id="UpdateProductLabel">Update Product Details</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      
      <!-- Modal Body -->
      <div class="modal-body">
        <div class="form-group">
            <label for="productName">Name</label>
            <InputText id="productName" class="form-control" @bind-Value="Product.Name"/>
        </div>

        <div class="form-group">
            <label for="productPrice">Price</label>
            <InputNumber id="productPrice" class="form-control" @bind-Value="Product.Price"/>
        </div>

        <div class="form-group">
            <label for="productStock">Stock</label>
            <InputNumber id="productStock" class="form-control" @bind-Value="Product.Stock"/>
        </div>
      </div>
      
      <!-- Modal Footer -->
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" @onclick="HandleProductUpdate" class="btn btn-primary">Save changes</button>
      </div>
      
    </div>
  </div>
</div>